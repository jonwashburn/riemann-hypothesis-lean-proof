import Mathlib
import infrastructure.WeightedHilbertSpace

/-!
This file introduces the weighted‚Äêaction functional on the strengthened
Hilbert space `WeightedHilbertSpaceEps Œµ` and states a **uniform bound**
that is needed in the operator‚Äìtheoretic Riemann‚ÄìHypothesis proof.
The analytic proof is long but elementary; to unblock compilation we
record the lemma as an axiom for the moment.  A complete formal proof
can be supplied later without touching dependent files.
-/

open scoped BigOperators Real
open Complex

variable {Œµ Œ≤ : ‚Ñù}

/-- The weighted action functional
    `J_{Œ≤,Œµ}(œà) = ‚àë |c_p|¬≤ (log p)^{2Œ≤}` on the Œµ‚Äìweighted space. -/
noncomputable def actionFunctionalEps (Œ≤ Œµ : ‚Ñù)
    (œà : WeightedHilbertSpaceEps Œµ) : ‚Ñù :=
  ‚àë' p : {p : ‚Ñï // Nat.Prime p}, ‚Äñœà.val p‚Äñ^2 * (Real.log p.val)^(2 * Œ≤)

/-- Helper lemma: For any positive Œµ and Œ≤ < 1/2, we have (log p)^{2Œ≤} ‚â§ C¬∑p^{Œµ/2}
    for some constant C depending on Œ≤ and Œµ. -/
lemma log_pow_le_rpow_eventually (hŒµ : 0 < Œµ) (hŒ≤ : Œ≤ < 1/2) :
    ‚àÉ C : ‚Ñù, 0 < C ‚àß ‚àÄ·∂† p : {p : ‚Ñï // Nat.Prime p} in Filter.cofinite,
      (Real.log p.val)^(2 * Œ≤) ‚â§ C * (p.val : ‚Ñù)^(Œµ/2) := by
  -- Key insight: log grows slower than any positive power
  -- We use that log x / x^Œ± ‚Üí 0 as x ‚Üí ‚àû for any Œ± > 0
  use (2 / Œµ)^(2 * Œ≤)
  constructor
  ¬∑ apply rpow_pos_of_pos
    exact div_pos two_pos hŒµ
  ¬∑ -- Show that eventually (log p)^{2Œ≤} ‚â§ ((2/Œµ)p^{Œµ/2})^{2Œ≤}
    have h_lim : Filter.Tendsto (fun n : ‚Ñï => (Real.log n) / (n : ‚Ñù)^(Œµ/2))
        Filter.atTop (ùìù 0) := by
      apply Real.tendsto_log_div_rpow_atTop_nhds_zero
      exact half_pos hŒµ
    rw [Filter.tendsto_nhds_eq_zero_iff] at h_lim
    have h_bound := h_lim 1 one_pos
    rw [Filter.eventually_atTop] at h_bound
    obtain ‚ü®N, hN‚ü© := h_bound
    -- Convert to cofinite filter on primes
    apply Filter.eventually_cofinite_of_finite
    simp only [Set.finite_setOf_mem, Set.mem_setOf]
    apply Set.Finite.subset (Set.finite_Iio N)
    intro p hp
    simp only [Set.mem_Iio]
    by_contra h_ge
    -- If p.val ‚â• N, then we have the bound
    have h_ineq := hN p.val h_ge
    rw [Real.abs_sub_lt_iff] at h_ineq
    have : (Real.log p.val) / (p.val : ‚Ñù)^(Œµ/2) < 1 := h_ineq.2
    have : Real.log p.val < (p.val : ‚Ñù)^(Œµ/2) := by
      rwa [div_lt_iff] at this
      apply rpow_pos_of_pos
      exact Nat.cast_pos.mpr p.prop.pos
    -- Take 2Œ≤-th power
    have h_pow : (Real.log p.val)^(2 * Œ≤) < ((p.val : ‚Ñù)^(Œµ/2))^(2 * Œ≤) := by
      apply Real.rpow_lt_rpow_of_exponent_pos
      ¬∑ exact Real.log_nonneg (Nat.one_le_cast.mpr p.prop.one_lt.le)
      ¬∑ exact this
      ¬∑ exact mul_pos two_pos (by linarith : 0 < Œ≤)
    -- Simplify the RHS
    rw [‚Üê Real.rpow_natCast_mul] at h_pow
    have : ((p.val : ‚Ñù)^(Œµ/2))^(2 * Œ≤) = (p.val : ‚Ñù)^(Œµ * Œ≤) := by
      rw [‚Üê Real.rpow_natCast_mul]
      ring_nf
    rw [this] at h_pow
    -- But we claimed the opposite in hp
    have h_not : ¬¨((Real.log p.val)^(2 * Œ≤) ‚â§ (2 / Œµ)^(2 * Œ≤) * (p.val : ‚Ñù)^(Œµ/2)) := hp
    apply h_not
    calc (Real.log p.val)^(2 * Œ≤)
        < (p.val : ‚Ñù)^(Œµ * Œ≤) := h_pow
      _ ‚â§ (p.val : ‚Ñù)^(Œµ/2) := by
        apply Real.rpow_le_rpow_of_exponent_le
        ¬∑ exact Nat.one_le_cast.mpr p.prop.one_lt.le
        ¬∑ linarith
      _ ‚â§ (2 / Œµ)^(2 * Œ≤) * (p.val : ‚Ñù)^(Œµ/2) := by
        rw [le_mul_iff_one_le_left]
        ¬∑ apply one_le_rpow_of_pos_of_le_one_of_nonpos
          ¬∑ exact div_pos two_pos hŒµ
          ¬∑ apply div_le_one_of_le
            ¬∑ exact le_refl 2
            ¬∑ exact hŒµ
          ¬∑ linarith
        ¬∑ apply rpow_pos_of_pos
          exact Nat.cast_pos.mpr p.prop.pos

/-- Uniform bound on finite sets of primes -/
lemma finite_prime_bound (hŒµ : 0 < Œµ) (hŒ≤ : 0 < Œ≤) (S : Finset {p : ‚Ñï // Nat.Prime p}) :
    ‚àÉ C : ‚Ñù, 0 < C ‚àß ‚àÄ œà : WeightedHilbertSpaceEps Œµ, ‚Äñœà‚Äñ ‚â§ 1 ‚Üí
      ‚àë p in S, ‚Äñœà.val p‚Äñ^2 * (Real.log p.val)^(2 * Œ≤) ‚â§ C := by
  -- On finite sets, the maximum of log^{2Œ≤} over primes gives a bound
  use S.card * (Finset.sup S (fun p => (Real.log p.val)^(2 * Œ≤)))
  constructor
  ¬∑ apply mul_pos
    ¬∑ exact Nat.cast_pos.mpr (Finset.card_pos.mpr ‚ü®‚ü®2, Nat.prime_two‚ü©, by simp‚ü©)
    ¬∑ apply Finset.lt_sup_iff.mpr
      use ‚ü®2, Nat.prime_two‚ü©
      constructor
      ¬∑ simp
      ¬∑ apply rpow_pos_of_pos
        exact Real.log_pos one_lt_two
  ¬∑ intro œà hœà
    calc ‚àë p in S, ‚Äñœà.val p‚Äñ^2 * (Real.log p.val)^(2 * Œ≤)
        ‚â§ ‚àë p in S, 1 * (Real.log p.val)^(2 * Œ≤) := by
          apply Finset.sum_le_sum
          intro p _
          apply mul_le_mul_of_nonneg_right
          ¬∑ exact sq_le_one (abs_nonneg _) (le_trans (abs_nonneg _) (by simp))
          ¬∑ apply rpow_nonneg
            exact Real.log_nonneg (Nat.one_le_cast.mpr p.prop.one_lt.le)
      _ = ‚àë p in S, (Real.log p.val)^(2 * Œ≤) := by simp
      _ ‚â§ S.card * Finset.sup S (fun p => (Real.log p.val)^(2 * Œ≤)) := by
          apply Finset.sum_le_card_mul_sup

/-- Helper: For unit vectors in weighted ‚Ñì¬≤, individual terms are bounded -/
lemma weighted_l2_term_bound (Œµ : ‚Ñù) (hŒµ : 0 < Œµ) (œà : WeightedHilbertSpaceEps Œµ) (hœà : ‚Äñœà‚Äñ ‚â§ 1) :
    ‚àÄ p : {p : ‚Ñï // Nat.Prime p}, ‚Äñœà.val p‚Äñ^2 * (primeWeightEps Œµ p).toReal ‚â§ 1 := by
  intro p
  -- Key fact: ‚Äñœà‚Äñ in lp space is defined via the sum of weighted components
  -- Since œà ‚àà WeightedHilbertSpaceEps Œµ, we know the sum converges
  have h_mem : œà.val ‚àà lp (fun p => primeWeightEps Œµ p) 2 := œà.property
  -- Get summability from membership
  have h_summable : Summable (fun q => ‚Äñœà.val q‚Äñ^2 * (primeWeightEps Œµ q).toReal) := by
    rw [lp.mem_‚Ñìp_iff_summable] at h_mem
    ¬∑ exact h_mem
    ¬∑ norm_num
  -- For lp space with p=2, the norm squared equals the weighted sum
  have h_norm_sq : ‚Äñœà‚Äñ^2 = ‚àë' q, ‚Äñœà.val q‚Äñ^2 * (primeWeightEps Œµ q).toReal := by
    -- The norm in lp 2 is defined as the square root of the weighted sum
    -- ‚Äñf‚Äñ_{lp 2} = (‚àë |f_i|^2 * w_i)^{1/2}, so ‚Äñf‚Äñ^2 = ‚àë |f_i|^2 * w_i
    -- This follows from the definition of lp norm for p = 2
    sorry -- TODO: Use lp.norm_def or similar when exact lemma name is confirmed
  -- Since ‚Äñœà‚Äñ ‚â§ 1, the sum is ‚â§ 1
  have h_sum : ‚àë' q, ‚Äñœà.val q‚Äñ^2 * (primeWeightEps Œµ q).toReal ‚â§ 1 := by
    rw [‚Üê h_norm_sq]
    exact sq_le_one' hœà
  -- Each non-negative term is bounded by the total
  have h_nonneg : 0 ‚â§ ‚Äñœà.val p‚Äñ^2 * (primeWeightEps Œµ p).toReal := by
    apply mul_nonneg (sq_nonneg _)
    exact ENNReal.toReal_nonneg
  exact le_trans (le_tsum' h_summable p) h_sum

/-- For every `Œµ > 0` and every `Œ≤` with `0 < Œ≤ < 1/2` the action
functional is **uniformly bounded** on the unit sphere of the
Œµ‚Äìweighted Hilbert space. -/
lemma actionFunctional_boundedEps
    (hŒµ : 0 < Œµ) (hŒ≤‚ÇÅ : 0 < Œ≤) (hŒ≤‚ÇÇ : Œ≤ < (1/2)) :
    ‚àÉ C : ‚Ñù, 0 < C ‚àß
      ‚àÄ œà : WeightedHilbertSpaceEps Œµ, ‚Äñœà‚Äñ ‚â§ 1 ‚Üí
        actionFunctionalEps Œ≤ Œµ œà ‚â§ C := by
  -- Get the eventual bound from log_pow_le_rpow_eventually
  obtain ‚ü®C‚ÇÅ, hC‚ÇÅ_pos, h_eventually‚ü© := log_pow_le_rpow_eventually hŒµ hŒ≤‚ÇÇ

  -- The set of primes where the bound fails is finite
  have h_finite : {p : {p : ‚Ñï // Nat.Prime p} | ¬¨((Real.log p.val)^(2 * Œ≤) ‚â§
      C‚ÇÅ * (p.val : ‚Ñù)^(Œµ/2))}.Finite := by
    exact Filter.eventually_cofinite.mp h_eventually

  -- Get a bound on this finite set
  let S := h_finite.toFinset
  obtain ‚ü®C‚ÇÇ, hC‚ÇÇ_pos, h_finite_bound‚ü© := finite_prime_bound hŒµ hŒ≤‚ÇÅ S

  -- The tail sum converges because ‚àë p^{-(2+Œµ/2)} converges
  have h_tail_summable : Summable (fun p : {p : ‚Ñï // Nat.Prime p} =>
      C‚ÇÅ * (p.val : ‚Ñù)^(Œµ/2) * (p.val : ‚Ñù)^(-(2+Œµ))) := by
    simp only [mul_assoc]
    rw [‚Üê mul_rpow (Nat.cast_nonneg _) (Nat.cast_nonneg _)]
    simp only [‚Üê add_mul, div_mul_cancel' _ (ne_of_gt (half_pos hŒµ))]
    apply Summable.mul_left
    -- ‚àë p^{-(2+Œµ/2)} converges because 2+Œµ/2 > 1
    have h_exp : 1 < 2 + Œµ/2 := by linarith
    -- Convert to summability over naturals
    have : Summable (fun n : ‚Ñï => if n.Prime then (n : ‚Ñù)^(-(2+Œµ/2)) else 0) := by
      apply Summable.of_norm_bounded _ (Real.summable_nat_rpow_inv.mpr h_exp)
      intro n
      split_ifs
      ¬∑ simp only [Real.norm_eq_abs, abs_rpow_of_nonneg (Nat.cast_nonneg _)]
        exact le_refl _
      ¬∑ simp
    exact Summable.subtype_iff_indicator.mp this

  -- Choose C = C‚ÇÇ + (tail sum bound)
  let C‚ÇÉ := ‚àë' p : {p : ‚Ñï // Nat.Prime p}, C‚ÇÅ * (p.val : ‚Ñù)^(Œµ/2) * (p.val : ‚Ñù)^(-(2+Œµ))
  use C‚ÇÇ + C‚ÇÉ

  constructor
  ¬∑ apply add_pos hC‚ÇÇ_pos
    apply tsum_pos
    ¬∑ intro p
      apply mul_pos (mul_pos hC‚ÇÅ_pos _)
      ¬∑ apply rpow_pos_of_pos
        exact Nat.cast_pos.mpr p.prop.pos
      ¬∑ apply rpow_pos_of_pos
        exact Nat.cast_pos.mpr p.prop.pos
    ¬∑ exact h_tail_summable

  intro œà hœà
  unfold actionFunctionalEps

  -- Split the sum into finite part and tail
  have h_split : ‚àë' p, ‚Äñœà.val p‚Äñ^2 * (Real.log p.val)^(2 * Œ≤) =
      ‚àë p in S, ‚Äñœà.val p‚Äñ^2 * (Real.log p.val)^(2 * Œ≤) +
      ‚àë' p : {p // p ‚àâ S}, ‚Äñœà.val (p : {p : ‚Ñï // Nat.Prime p})‚Äñ^2 *
        (Real.log (p : {p : ‚Ñï // Nat.Prime p}).val)^(2 * Œ≤) := by
    rw [‚Üê Finset.sum_add_tsum_compl]
    ¬∑ congr 1
      ext p
      rfl
    ¬∑ -- Need to show summability
      apply Summable.of_norm_bounded _ _
      ¬∑ intro p
        simp only [Real.norm_eq_abs]
        apply abs_mul_nonneg
      ¬∑ -- Use that œà is in the weighted space
        have h_œà_summable : Summable (fun p => ‚Äñœà.val p‚Äñ^2 * (primeWeightEps Œµ p).toReal) := by
          have := œà.property
          rw [Mem‚Ñìp.summable_iff] at this
          ¬∑ convert this
            ext p
            simp [primeWeightEps, ENNReal.toReal_rpow]
          ¬∑ norm_num
        -- Apply the eventual bound
        apply Summable.of_nonneg_of_le
        ¬∑ intro p
          apply mul_nonneg (sq_nonneg _)
          apply rpow_nonneg
          exact Real.log_nonneg (Nat.one_le_cast.mpr p.prop.one_lt.le)
        ¬∑ intro p
          by_cases hp : (p : {p : ‚Ñï // Nat.Prime p}) ‚àà S
          ¬∑ exfalso
            exact p.property hp
          ¬∑ -- Use the eventual bound
            have h_bound : (Real.log p.val)^(2 * Œ≤) ‚â§ C‚ÇÅ * (p.val : ‚Ñù)^(Œµ/2) := by
              have : (p : {p : ‚Ñï // Nat.Prime p}) ‚àâ S := hp
              rw [Set.Finite.mem_toFinset] at this
              push_neg at this
              exact this
            calc ‚Äñœà.val (p : {p : ‚Ñï // Nat.Prime p})‚Äñ^2 * (Real.log p.val)^(2 * Œ≤)
                ‚â§ ‚Äñœà.val (p : {p : ‚Ñï // Nat.Prime p})‚Äñ^2 * (C‚ÇÅ * (p.val : ‚Ñù)^(Œµ/2)) := by
                  apply mul_le_mul_of_nonneg_left h_bound (sq_nonneg _)
              _ = C‚ÇÅ * ‚Äñœà.val (p : {p : ‚Ñï // Nat.Prime p})‚Äñ^2 * (p.val : ‚Ñù)^(Œµ/2) := by ring
              _ ‚â§ C‚ÇÅ * (primeWeightEps Œµ (p : {p : ‚Ñï // Nat.Prime p})).toReal *
                    (p.val : ‚Ñù)^(Œµ/2) * (p.val : ‚Ñù)^(2+Œµ) := by
                  apply mul_le_mul_of_nonneg_right
                  apply mul_le_mul_of_nonneg_left
                  ¬∑ exact weighted_l2_term_bound Œµ hŒµ œà hœà (p : {p : ‚Ñï // Nat.Prime p})
                  ¬∑ exact hC‚ÇÅ_pos.le
                  ¬∑ apply rpow_nonneg; exact Nat.cast_nonneg _
              _ = C‚ÇÅ * (p.val : ‚Ñù)^(Œµ/2) * (p.val : ‚Ñù)^(-(2+Œµ)) := by
                  simp [primeWeightEps, ENNReal.toReal_rpow]
                  ring
        ¬∑ -- Show the series we're bounding matches h_tail_summable
          apply h_tail_summable

  rw [h_split]
  apply add_le_add
  ¬∑ exact h_finite_bound œà hœà
  ¬∑ -- Bound the tail sum
    -- We showed each term ‚â§ C‚ÇÅ * ‚Äñœà p‚Äñ¬≤ * weight * p^{Œµ/2} * p^{2+Œµ}
    -- And since ‚Äñœà‚Äñ ‚â§ 1, we have ‚àë ‚Äñœà p‚Äñ¬≤ * weight ‚â§ 1
    -- So the tail is bounded by C‚ÇÅ * ‚àë p^{-(2+Œµ/2)} = C‚ÇÉ
    calc ‚àë' p : {p // p ‚àâ S}, ‚Äñœà.val (p : {p : ‚Ñï // Nat.Prime p})‚Äñ^2 *
          (Real.log (p : {p : ‚Ñï // Nat.Prime p}).val)^(2 * Œ≤)
        ‚â§ ‚àë' p : {p // p ‚àâ S}, C‚ÇÅ * (p.val : ‚Ñù)^(Œµ/2) * (p.val : ‚Ñù)^(-(2+Œµ)) := by
          -- Apply the pointwise bound we established
          apply tsum_le_tsum
          ¬∑ intro p
            -- We established this bound earlier in the proof
            have hp : (p : {p : ‚Ñï // Nat.Prime p}) ‚àâ S := p.property
            have h_bound : (Real.log p.val)^(2 * Œ≤) ‚â§ C‚ÇÅ * (p.val : ‚Ñù)^(Œµ/2) := by
              -- This follows from h_eventually and the definition of S
              have : (p : {p : ‚Ñï // Nat.Prime p}) ‚àâ S := hp
              rw [Set.Finite.mem_toFinset] at this
              push_neg at this
              exact this
            calc ‚Äñœà.val (p : {p : ‚Ñï // Nat.Prime p})‚Äñ^2 * (Real.log p.val)^(2 * Œ≤)
                ‚â§ ‚Äñœà.val (p : {p : ‚Ñï // Nat.Prime p})‚Äñ^2 * (C‚ÇÅ * (p.val : ‚Ñù)^(Œµ/2)) := by
                  apply mul_le_mul_of_nonneg_left h_bound (sq_nonneg _)
              _ = C‚ÇÅ * ‚Äñœà.val (p : {p : ‚Ñï // Nat.Prime p})‚Äñ^2 * (p.val : ‚Ñù)^(Œµ/2) := by ring
              _ ‚â§ C‚ÇÅ * (primeWeightEps Œµ (p : {p : ‚Ñï // Nat.Prime p})).toReal *
                    (p.val : ‚Ñù)^(Œµ/2) * (p.val : ‚Ñù)^(2+Œµ) := by
                  apply mul_le_mul_of_nonneg_right
                  apply mul_le_mul_of_nonneg_left
                  ¬∑ exact weighted_l2_term_bound Œµ hŒµ œà hœà (p : {p : ‚Ñï // Nat.Prime p})
                  ¬∑ exact hC‚ÇÅ_pos.le
                  ¬∑ apply rpow_nonneg; exact Nat.cast_nonneg _
              _ = C‚ÇÅ * (p.val : ‚Ñù)^(Œµ/2) * (p.val : ‚Ñù)^(-(2+Œµ)) := by
                  simp [primeWeightEps, ENNReal.toReal_rpow]
                  ring
          ¬∑ -- Summability of LHS follows from the fact that œà is in the weighted space
            -- We have œà ‚àà WeightedHilbertSpaceEps Œµ, so ‚àë ‚Äñœà p‚Äñ¬≤ * weight < ‚àû
            -- And (log p)^{2Œ≤} is eventually bounded by p^{Œµ/2}
            -- So the product is summable
            apply Summable.of_norm_bounded_eventually _ _
            ¬∑ -- The comparison series
              convert h_tail_summable using 1
              ext p
              simp only [norm_mul, Real.norm_eq_abs, abs_mul]
              ring
            ¬∑ -- Eventually the bound holds
              filter_upwards [h_eventually] with p hp
              -- We need to show norm bound
              simp only [norm_mul, Real.norm_eq_abs]
              -- All terms are non-negative
              simp only [abs_mul, abs_sq, abs_rpow_of_nonneg (Real.log_nonneg
                (Nat.one_le_cast.mpr p.prop.one_lt.le)),
                abs_rpow_of_nonneg (Nat.cast_nonneg _)]
              -- Apply the bound we already established above
              by_cases h_mem : (p : {p : ‚Ñï // Nat.Prime p}) ‚àà S
              ¬∑ -- If p ‚àà S, we don't need the bound (contradiction with p ‚àâ S)
                exfalso
                exact p.property h_mem
              ¬∑ -- Use the calc we proved above
                have h_bound : (Real.log p.val)^(2 * Œ≤) ‚â§ C‚ÇÅ * (p.val : ‚Ñù)^(Œµ/2) := by
                  rw [Set.Finite.mem_toFinset] at h_mem
                  push_neg at h_mem
                  exact h_mem
                calc ‚Äñœà.val (p : {p : ‚Ñï // Nat.Prime p})‚Äñ^2 * (Real.log p.val)^(2 * Œ≤)
                    ‚â§ ‚Äñœà.val (p : {p : ‚Ñï // Nat.Prime p})‚Äñ^2 * (C‚ÇÅ * (p.val : ‚Ñù)^(Œµ/2)) := by
                      apply mul_le_mul_of_nonneg_left h_bound (sq_nonneg _)
                  _ = C‚ÇÅ * ‚Äñœà.val (p : {p : ‚Ñï // Nat.Prime p})‚Äñ^2 * (p.val : ‚Ñù)^(Œµ/2) := by ring
                  _ ‚â§ C‚ÇÅ * 1 * (p.val : ‚Ñù)^(Œµ/2) := by
                      apply mul_le_mul_of_nonneg_right
                      apply mul_le_mul_of_nonneg_left
                      ¬∑ exact weighted_l2_term_bound Œµ hŒµ œà hœà (p : {p : ‚Ñï // Nat.Prime p})
                      ¬∑ exact hC‚ÇÅ_pos.le
                      ¬∑ apply rpow_nonneg; exact Nat.cast_nonneg _
                  _ = C‚ÇÅ * (p.val : ‚Ñù)^(Œµ/2) * (p.val : ‚Ñù)^(-(2+Œµ)) * (p.val : ‚Ñù)^(2+Œµ) := by
                      rw [mul_comm (C‚ÇÅ * _), ‚Üê mul_assoc]
                      rw [‚Üê rpow_add (Nat.cast_pos.mpr p.prop.pos)]
                      simp
                  _ = C‚ÇÅ * (p.val : ‚Ñù)^(Œµ/2) * (p.val : ‚Ñù)^(-(2+Œµ)) := by
                      ring
      _ ‚â§ C‚ÇÉ := by
          -- This is exactly how we defined C‚ÇÉ
          rfl
